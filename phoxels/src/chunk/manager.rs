use std::{any::Any, fmt::Debug, marker::PhantomData, panic, sync::Arc};

use crate::core::*;
use bevy::{
    asset::Assets,
    ecs::{
        bundle::{Bundle, DynamicBundle},
        component::ComponentId,
        query::{QueryData, ReadOnlyQueryData},
        reflect::AppTypeRegistry,
    },
    platform::collections::HashMap,
    prelude::{Component, Entity, Query, Res, ResMut, Resource},
    reflect::{
        DynamicTuple, FromReflect, GetTypeRegistration, PartialReflect, Reflect, ReflectFromPtr,
        Tuple, TupleInfo, TypeInfo,
    },
    render::{
        mesh::{Mesh, Mesh3d},
        primitives::Aabb,
    },
    tasks::Task,
};
use indexmap::IndexSet;

#[derive(Resource, Default)]
pub struct ChunkGenerator<T: Block> {
    to_generate: IndexSet<Entity>,
    generating: HashMap<Entity, Task<ChunkData<T>>>,
    old_generating: HashMap<Entity, Task<ChunkData<T>>>,
}

impl<T: Block> ChunkGenerator<T> {
    /// Adds a chunk to the queue to have its data generated.
    pub fn add_to_queue(&mut self, chunk_id: Entity) {
        self.to_generate.insert(chunk_id);
    }

    pub fn generating(&self) -> usize {
        self.generating.len()
    }

    pub fn len(&self) -> usize {
        self.to_generate.len() + self.generating()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    // Sets the priority of the chunks to generate based on a custom function.
    // The chunk ordered greater than the other will be generated first
    // pub fn set_priority<F: FnMut(&ChunkId, &ChunkId) -> std::cmp::Ordering>(&mut self, func: F) {
    //     self.to_generate.sort_by(func);
    // }
}

#[derive(Resource, Default)]
pub struct ChunkMesher {
    to_generate: IndexSet<Entity>,
    generating: HashMap<Entity, Task<Option<(Mesh, Aabb)>>>,
    old_generating: HashMap<Entity, Task<Option<(Mesh, Aabb)>>>,
}

impl ChunkMesher {
    /// Adds a chunk to the queue to have its mesh generated.
    pub fn add_to_queue(&mut self, chunk_id: Entity) {
        self.to_generate.insert(chunk_id);
    }

    pub fn generating(&self) -> usize {
        self.generating.len()
    }

    pub fn len(&self) -> usize {
        self.to_generate.len() + self.generating()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    // Sets the priority of the chunks to generate based on a custom function.
    // The chunk ordered greater than the other will be generated first?
    // pub fn set_priority<F: FnMut(&ChunkId, &ChunkId) -> std::cmp::Ordering>(&mut self, func: F) {
    //     self.to_generate.sort_by(func);
    // }
}

/// `PhoxelGenerator` is a resource that holds a closure for generating `ChunkData` based on a `ChunkId`.
/// If used as a resource in Bevy, it allows you to define how chunks are generated by default.
/// If used as a component, it can be inserted to override the default generation.
#[derive(Resource)]
pub struct PhoxelGenerator<T: Block, D: PhoxelGeneratorData = ()>(
    Arc<dyn Fn(D) -> ChunkData<T> + Send + Sync>,
);

impl<D: PhoxelGeneratorData, T: Block> Clone for PhoxelGenerator<T, D> {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}

pub struct PhoxelGeneratorDataFetch<T: PhoxelGeneratorData> {
    _marker: std::marker::PhantomData<T>,
}

pub struct DataState<T: PhoxelGeneratorData> {
    components: Vec<ComponentId>,
    type_info: &'static TypeInfo,
    _market: std::marker::PhantomData<T>,
}

pub struct DataFetch<'a> {
    world: bevy::ecs::world::unsafe_world_cell::UnsafeWorldCell<'a>,
    type_registry: AppTypeRegistry,
    dynamic_reflect: Box<dyn PartialReflect>,
    tuple_type: &'static TypeInfo,
    targets: Vec<ComponentId>,
}

impl Clone for DataFetch<'_> {
    fn clone(&self) -> Self {
        Self {
            type_registry: self.type_registry.clone(),
            tuple_type: self.tuple_type,
            targets: self.targets.clone(),
            world: self.world,
            dynamic_reflect: self
                .dynamic_reflect
                .as_partial_reflect()
                .reflect_clone()
                .unwrap(),
        }
    }
}

unsafe impl<T: PhoxelGeneratorData + Bundle + Debug + GetTypeRegistration + FromReflect>
    ReadOnlyQueryData for PhoxelGeneratorDataFetch<T>
{
}

unsafe impl<T: PhoxelGeneratorData + Bundle + Debug + GetTypeRegistration>
    bevy::ecs::query::WorldQuery for PhoxelGeneratorDataFetch<T>
{
    type Fetch<'a> = DataFetch<'a>;

    type State = DataState<T>;

    fn shrink_fetch<'wlong: 'wshort, 'wshort>(fetch: Self::Fetch<'wlong>) -> Self::Fetch<'wshort> {
        fetch
    }

    unsafe fn init_fetch<'w>(
        world: bevy::ecs::world::unsafe_world_cell::UnsafeWorldCell<'w>,
        state: &Self::State,
        _last_run: bevy::ecs::component::Tick,
        _this_run: bevy::ecs::component::Tick,
    ) -> Self::Fetch<'w> {
        DataFetch {
            type_registry: unsafe {
                world
                    .get_resource::<AppTypeRegistry>()
                    .cloned()
                    .expect("`AppTypeRegistry` exists")
            },
            tuple_type: state.type_info,
            targets: state.components.clone(),
            world,
            dynamic_reflect: T::default().to_dynamic(),
        }
    }

    const IS_DENSE: bool = false;

    unsafe fn set_archetype<'w>(
        _fetch: &mut Self::Fetch<'w>,
        _state: &Self::State,
        _archetype: &'w bevy::ecs::archetype::Archetype,
        _table: &'w bevy::ecs::storage::Table,
    ) {
        // fetch.row = archetype.entity_table_row(fetch.archetype_row);
    }

    unsafe fn set_table<'w>(
        _fetch: &mut Self::Fetch<'w>,
        _state: &Self::State,
        _table: &'w bevy::ecs::storage::Table,
    ) {
        // fetch.has_generator = table.has_column(state.generator_component);
    }

    fn update_component_access(
        state: &Self::State,
        access: &mut bevy::ecs::query::FilteredAccess<bevy::ecs::component::ComponentId>,
    ) {
        for id in state.components.iter() {
            access.add_component_read(*id);
        }
    }

    fn init_state(world: &mut bevy::ecs::world::World) -> Self::State {
        let mut components = Vec::new();
        let mut add = |id| {
            components.push(id);
        };
        <T as Bundle>::component_ids(&mut world.components_registrator(), &mut add);
        let tr = world.resource::<AppTypeRegistry>().clone();
        let mut tr = tr.write();
        tr.register::<T>();
        drop(tr);
        DataState {
            components,
            type_info: T::get_type_registration().type_info(),
            _market: std::marker::PhantomData,
        }
    }

    fn get_state(components: &bevy::ecs::component::Components) -> Option<Self::State> {
        let mut my_components = Vec::new();
        let mut failed = false;
        let mut add = |id| {
            if let Some(id) = id {
                my_components.push(id);
            } else {
                failed = true;
            }
        };
        <T as Bundle>::get_component_ids(components, &mut add);

        if failed {
            None
        } else {
            Some(DataState {
                components: my_components,
                type_info: T::get_type_registration().type_info(),
                _market: std::marker::PhantomData,
            })
        }
    }

    fn matches_component_set(
        state: &Self::State,
        set_contains_id: &impl Fn(bevy::ecs::component::ComponentId) -> bool,
    ) -> bool {
        for id in state.components.iter() {
            if !set_contains_id(*id) {
                return false;
            }
        }
        true
    }
}

unsafe impl<T: PhoxelGeneratorData + Debug> bevy::ecs::query::QueryData
    for PhoxelGeneratorDataFetch<T>
{
    const IS_READ_ONLY: bool = true;

    type ReadOnly = Self;

    type Item<'a> = T;

    fn shrink<'wlong: 'wshort, 'wshort>(item: Self::Item<'wlong>) -> Self::Item<'wshort> {
        item
    }

    unsafe fn fetch<'w>(
        fetch: &mut Self::Fetch<'w>,
        entity: Entity,
        _table_row: bevy::ecs::storage::TableRow,
    ) -> Self::Item<'w> {
        if let Ok(e) = fetch.world.get_entity(entity) {
            let tr = fetch.type_registry.read();

            match fetch
                .dynamic_reflect
                .as_partial_reflect()
                .get_represented_type_info()
                .unwrap()
            {
                TypeInfo::Struct(_) | TypeInfo::TupleStruct(_) => {
                    let info = fetch
                        .world
                        .components()
                        .get_info(fetch.targets[0])
                        .expect("all type already registered");
                    let Some(t) =
                        tr.get_type_data::<ReflectFromPtr>(info.type_id().expect("has type id"))
                    else {
                        panic!("FromPointer not found for type {:?}", info.name());
                    };
                    unsafe {
                        let val = e
                            .get_by_id(fetch.targets[0])
                            .expect("Entity should have the component");
                        let from_ptr = t.from_ptr();
                        let v = from_ptr(val);
                        return T::from_reflect(v).expect("all components should be found");
                    }
                }
                TypeInfo::Tuple(_tuple_info) => {
                    let mut dynamic_tuple = DynamicTuple::default();
                    for target in fetch.targets.iter() {
                        unsafe {
                            let Some(val) = e.get_by_id(*target) else {
                                panic!("Entity {:?} does not have component {:?}", entity, target);
                            };
                            let info = fetch
                                .world
                                .components()
                                .get_info(*target)
                                .expect("all type already registered");
                            let Some(from_ptr) = tr.get_type_data::<ReflectFromPtr>(
                                info.type_id().expect("all componet have type id?"),
                            ) else {
                                panic!("FromPointer not found for type {:?}", info.type_id());
                            };
                            let from_fn = from_ptr.from_ptr();
                            let val = from_fn(val);
                            let val = val
                                .reflect_clone()
                                .expect("all components should be cloneable");
                            dynamic_tuple.insert_boxed(val);
                        }
                    }
                    fetch
                        .dynamic_reflect
                        .apply(dynamic_tuple.as_partial_reflect());
                }
                TypeInfo::List(_list_info) => todo!(),
                TypeInfo::Array(_array_info) => todo!(),
                TypeInfo::Map(_map_info) => todo!(),
                TypeInfo::Set(_set_info) => todo!(),
                TypeInfo::Enum(_enum_info) => todo!(),
                TypeInfo::Opaque(_opaque_info) => todo!(),
            }
            T::from_reflect(fetch.dynamic_reflect.as_partial_reflect())
                .expect("all components should be found")
        } else {
            panic!("Entity {:?} not found in world", entity);
        }
    }
}

pub trait PhoxelGeneratorData:
    Send
    + Sync
    + Debug
    + Clone
    + Default
    + FromReflect
    + GetTypeRegistration
    + Bundle
    + Reflect
    + 'static
{
    fn to_owned(&self) -> Self {
        self.clone()
    }
}

// impl<'a, T: PhoxelGeneratorData + Clone> MakeOwned for (&'a T,) {
//     type Out = T;
//     fn to_owned(self) -> T {
//         self.0.clone()
//     }
// }

impl<
    T: Send
        + Sync
        + Clone
        + Bundle
        + Debug
        + Default
        + FromReflect
        + GetTypeRegistration
        + Reflect
        + 'static,
> PhoxelGeneratorData for T
{
}

// impl<T: Component + Clone> PhoxelGeneratorData for T {
//     // type QueryItem<'a> = (&'a T,);
//     type AsQuery<'a> = (&'a T,);
// }

// macro_rules! tuple_impl {
//     ($(#[$meta:meta])* $($name: ident),*) => {
//         #[expect(
//             clippy::allow_attributes,
//             reason = "This is a tuple-related macro; as such, the lints below may not always apply."
//         )]
//         #[allow(
//             unused_mut,
//             unused_variables,
//             reason = "Zero-length tuples won't use any of the parameters."
//         )]
//         $(#[$meta])*
//         // SAFETY:
//         // - `Bundle::component_ids` calls `ids` for each component type in the
//         // bundle, in the exact order that `DynamicBundle::get_components` is called.
//         // - `Bundle::from_components` calls `func` exactly once for each `ComponentId` returned by `Bundle::component_ids`.
//         // - `Bundle::get_components` is called exactly once for each member. Relies on the above implementation to pass the correct
//         //   `StorageType` into the callback.
//         impl<$($name: Component + Clone),*> PhoxelGeneratorData for ($($name,)*) {
//             type AsQuery<'a> = ($($name::AsQuery<'a>,)*);
//         }
//     }
// }

// all_tuples!(
//     #[doc(fake_variadic)]
//     tuple_impl,
//     1,
//     15,
//     D
// );

impl<D: PhoxelGeneratorData, T: Block> Component for PhoxelGenerator<T, D> {
    const STORAGE_TYPE: bevy::ecs::component::StorageType =
        bevy::ecs::component::StorageType::Table;

    type Mutability = bevy::ecs::component::Immutable;

    fn on_insert() -> Option<bevy::ecs::component::ComponentHook> {
        Some(Self::on_insert)
    }
}

impl<D: PhoxelGeneratorData, T: Block> PhoxelGenerator<T, D> {
    pub fn new<F: Fn(D) -> ChunkData<T> + Send + Sync + 'static>(f: F) -> Self {
        Self(Arc::new(f))
    }

    async fn generate(self, data: D) -> ChunkData<T> {
        (self.0)(data)
    }

    fn on_insert(
        mut world: bevy::ecs::world::DeferredWorld,
        ctx: bevy::ecs::component::HookContext,
    ) {
        world
            .commands()
            .entity(ctx.entity)
            .insert(PhoxelGenerate::<T>(PhantomData));
    }
}

/// `GeneratorLimits` is a resource that defines the max number of chunks that can be generated or meshed concurrently.
/// It is used to control the load on the system and prevent overwhelming the task pool.
/// It defaults to the number of threads in the Bevy async compute task pool.
#[derive(Resource, Debug, Clone, Copy)]
pub struct GeneratorLimits {
    pub max_generating_chunks: usize,
    pub max_meshing_chunks: usize,
}

impl Default for GeneratorLimits {
    fn default() -> Self {
        Self {
            max_generating_chunks: bevy::tasks::AsyncComputeTaskPool::get().thread_num(),
            max_meshing_chunks: bevy::tasks::AsyncComputeTaskPool::get().thread_num(),
        }
    }
}

pub(super) fn start_generating_chunk_data<D: PhoxelGeneratorData, T: Block>(
    default_generator: Option<Res<PhoxelGenerator<T, D>>>,
    mut generator: ResMut<ChunkGenerator<T>>,
    limits: Res<GeneratorLimits>,
    chunk_specific_generators: Query<&PhoxelGenerator<T, D>>,
    chunk_data: Query<PhoxelGeneratorDataFetch<D>>,
    #[cfg(target_arch = "wasm32")] mut commands: bevy::prelude::Commands,
) {
    if generator.generating() >= limits.max_generating_chunks {
        return;
    }
    if generator.to_generate.is_empty() {
        return;
    }
    let can_generate = limits.max_generating_chunks - generator.generating();
    let task_pool = bevy::tasks::AsyncComputeTaskPool::get();
    for _ in 0..generator.to_generate.len().min(can_generate) {
        let chunk_id = generator
            .to_generate
            .pop()
            .expect("to_generate should not be empty");
        #[cfg(feature = "log")]
        bevy::log::trace!("Generating data for chunk: {:?}", chunk_id);
        let voxel_generator = if let Ok(voxel_generator) = chunk_specific_generators.get(chunk_id) {
            voxel_generator
        } else if let Some(generator) = default_generator.as_ref() {
            generator.as_ref()
        } else {
            #[cfg(feature = "log")]
            bevy::log::error!(
                "No generator found for chunk: {:?}\n
                 No default Set",
                chunk_id
            );
            continue;
        };
        let Ok(d) = chunk_data.get(chunk_id) else {
            #[cfg(feature = "log")]
            bevy::log::error!("ChunkData not found for chunk: {:?}", chunk_id);
            continue;
        };
        let chunk_generator = voxel_generator.clone();
        let data = d.to_owned();
        #[cfg(target_arch = "wasm32")]
        {
            let data = chunk_generator.0(data);
            commands.entity(chunk_id).insert(data);
        }
        #[cfg(not(target_arch = "wasm32"))]
        generator
            .generating
            .insert(chunk_id, task_pool.spawn(chunk_generator.generate(data)));
    }
}

pub(super) fn start_generating_chunk_mesh<T: Block>(
    mut generator: ResMut<ChunkMesher>,
    limits: Res<GeneratorLimits>,
    chunk_data: Query<&ChunkData<T>>,
    #[cfg(target_arch = "wasm32")] mut commands: bevy::prelude::Commands,
    #[cfg(target_arch = "wasm32")] mut assets: bevy::prelude::ResMut<bevy::prelude::Assets<Mesh>>,
) {
    if generator.generating() >= limits.max_meshing_chunks {
        return;
    }
    if generator.to_generate.is_empty() {
        return;
    }
    let can_generate = limits.max_generating_chunks - generator.generating();
    let task_pool = bevy::tasks::AsyncComputeTaskPool::get();
    for _ in 0..generator.to_generate.len().min(can_generate) {
        let chunk_id = generator
            .to_generate
            .pop()
            .expect("to_generate should not be empty");
        #[cfg(feature = "log")]
        bevy::log::trace!("Generating mesh for chunk: {:?}", chunk_id);
        let Ok(chunk_data) = chunk_data.get(chunk_id) else {
            #[cfg(feature = "log")]
            bevy::log::error!("ChunkData not found for chunk: {:?}", chunk_id);
            continue;
        };
        #[cfg(target_arch = "wasm32")]
        {
            let Some((mesh, aabb)) = crate::chunk::mesh_gen::make_mesh(chunk_data.clone()) else {
                return;
            };
            commands
                .entity(chunk_id)
                .insert((Mesh3d(assets.add(mesh)), aabb));
        }
        #[cfg(not(target_arch = "wasm32"))]
        generator.generating.insert(
            chunk_id,
            task_pool.spawn(chunk_data.clone().generate_mesh()),
        );
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub(super) fn extract_finished_chunk_data<T: Block>(
    mut generator: ResMut<ChunkGenerator<T>>,
    mut commands: bevy::prelude::Commands,
) {
    let ChunkGenerator {
        generating,
        old_generating,
        ..
    } = generator.as_mut();
    if generating.is_empty() {
        return;
    }
    std::mem::swap(generating, old_generating);
    for (entity, task) in old_generating.drain() {
        if !task.is_finished() {
            generating.insert(entity, task);
            continue;
        }
        #[cfg(feature = "log")]
        bevy::log::trace!("Extracting finished data for chunk: {:?}", entity);
        let data = bevy::tasks::block_on(task);
        commands.entity(entity).insert(data);
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub(super) fn extract_finished_chunk_mesh(
    mut generator: ResMut<ChunkMesher>,
    mut commands: bevy::prelude::Commands,
    mut mesh_assets: ResMut<Assets<Mesh>>,
) {
    let ChunkMesher {
        generating,
        old_generating,
        ..
    } = generator.as_mut();
    if generating.is_empty() {
        return;
    }
    std::mem::swap(generating, old_generating);
    for (entity, task) in old_generating.drain() {
        if !task.is_finished() {
            generating.insert(entity, task);
            continue;
        }

        #[cfg(feature = "log")]
        bevy::log::trace!("Chunk {:?} has finished meshing inserting mesh", entity);

        let Some((mesh, aabb)) = bevy::tasks::block_on(task) else {
            return;
        };
        commands
            .entity(entity)
            .insert((Mesh3d(mesh_assets.add(mesh)), aabb));
    }
}

#[derive(Component)]
#[component(on_insert = PhoxelGenerate::<T>::on_insert)]
pub struct PhoxelGenerate<T: Block>(PhantomData<T>);

impl<T: Block> PhoxelGenerate<T> {
    fn on_insert(
        mut world: bevy::ecs::world::DeferredWorld,
        ctx: bevy::ecs::component::HookContext,
    ) {
        #[cfg(feature = "log")]
        bevy::log::trace!("added {:?} to `ChunkGenerator` que", ctx.entity);
        world
            .resource_mut::<ChunkGenerator<T>>()
            .add_to_queue(ctx.entity);
    }
}
