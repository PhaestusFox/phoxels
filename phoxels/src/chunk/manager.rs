use std::sync::Arc;

use crate::core::*;
use bevy::{
    asset::Assets,
    platform::collections::HashMap,
    prelude::{Component, Entity, Query, Res, ResMut, Resource},
    render::mesh::{Mesh, Mesh3d},
    tasks::Task,
};
use indexmap::IndexSet;

#[derive(Resource, Default)]
pub struct ChunkGenerator {
    to_generate: IndexSet<Entity>,
    generating: HashMap<Entity, Task<ChunkData>>,
    old_generating: HashMap<Entity, Task<ChunkData>>,
}

impl ChunkGenerator {
    /// Adds a chunk to the queue to have its data generated.
    pub fn add_to_queue(&mut self, chunk_id: Entity) {
        self.to_generate.insert(chunk_id);
    }

    fn generating(&self) -> usize {
        self.generating.len()
    }

    // Sets the priority of the chunks to generate based on a custom function.
    // The chunk ordered greater than the other will be generated first
    // pub fn set_priority<F: FnMut(&ChunkId, &ChunkId) -> std::cmp::Ordering>(&mut self, func: F) {
    //     self.to_generate.sort_by(func);
    // }
}

#[derive(Resource, Default)]
pub struct ChunkMesher {
    to_generate: IndexSet<Entity>,
    generating: HashMap<Entity, Task<Mesh>>,
    old_generating: HashMap<Entity, Task<Mesh>>,
}

impl ChunkMesher {
    /// Adds a chunk to the queue to have its mesh generated.
    pub fn add_to_queue(&mut self, chunk_id: Entity) {
        self.to_generate.insert(chunk_id);
    }

    fn generating(&self) -> usize {
        self.generating.len()
    }

    // Sets the priority of the chunks to generate based on a custom function.
    // The chunk ordered greater than the other will be generated first?
    // pub fn set_priority<F: FnMut(&ChunkId, &ChunkId) -> std::cmp::Ordering>(&mut self, func: F) {
    //     self.to_generate.sort_by(func);
    // }
}

/// `PhoxelGenerator` is a resource that holds a closure for generating `ChunkData` based on a `ChunkId`.
/// If used as a resource in Bevy, it allows you to define how chunks are generated by default.
/// If used as a component, it can be inserted to override the default generation.
#[derive(Resource, Component, Clone)]
#[component(immutable, on_insert = PhoxelGenerator::on_insert)]
// pub struct PhoxelGenerator(
//     Box<dyn Fn(ChunkId) -> Pin<Box<dyn Future<Output = ChunkData> + Send>> + Send + Sync>,
// );
pub struct PhoxelGenerator(Arc<dyn Fn() -> ChunkData + Send + Sync>);

impl PhoxelGenerator {
    pub fn new<F: Fn() -> ChunkData + Send + Sync + 'static>(f: F) -> Self {
        Self(Arc::new(f))
    }

    async fn generate(self) -> ChunkData {
        (self.0)()
    }

    fn on_insert(
        mut world: bevy::ecs::world::DeferredWorld,
        ctx: bevy::ecs::component::HookContext,
    ) {
        #[cfg(feature = "log")]
        bevy::log::trace!("added {:?} to `ChunkGenerator` que", ctx.entity);
        world
            .resource_mut::<ChunkGenerator>()
            .add_to_queue(ctx.entity);
    }
}

/// `GeneratorLimits` is a resource that defines the max number of chunks that can be generated or meshed concurrently.
/// It is used to control the load on the system and prevent overwhelming the task pool.
/// It defaults to the number of threads in the Bevy async compute task pool.
#[derive(Resource, Debug, Clone, Copy)]
pub struct GeneratorLimits {
    pub max_generating_chunks: usize,
    pub max_meshing_chunks: usize,
}

impl Default for GeneratorLimits {
    fn default() -> Self {
        Self {
            max_generating_chunks: bevy::tasks::AsyncComputeTaskPool::get().thread_num(),
            max_meshing_chunks: bevy::tasks::AsyncComputeTaskPool::get().thread_num(),
        }
    }
}

pub(super) fn start_generating_chunk_data(
    default_generator: Option<Res<PhoxelGenerator>>,
    mut generator: ResMut<ChunkGenerator>,
    limits: Res<GeneratorLimits>,
    chunk_specific_generators: Query<&PhoxelGenerator>,
) {
    if generator.generating() >= limits.max_generating_chunks {
        return;
    }
    if generator.to_generate.is_empty() {
        return;
    }
    let can_generate = limits.max_generating_chunks - generator.generating();
    let task_pool = bevy::tasks::AsyncComputeTaskPool::get();
    for _ in 0..generator.to_generate.len().min(can_generate) {
        let chunk_id = generator
            .to_generate
            .pop()
            .expect("to_generate should not be empty");
        #[cfg(feature = "log")]
        bevy::log::trace!("Generating data for chunk: {:?}", chunk_id);
        let chunk_generator = if let Ok(generator) = chunk_specific_generators.get(chunk_id) {
            generator
        } else if let Some(generator) = default_generator.as_ref() {
            generator
        } else {
            #[cfg(feature = "log")]
            bevy::log::error!(
                "No generator found for chunk: {:?}\nA Default was not provided",
                chunk_id
            );
            continue;
        };
        generator.generating.insert(
            chunk_id,
            task_pool.spawn(chunk_generator.clone().generate()),
        );
    }
}

pub(super) fn start_generating_chunk_mesh(
    mut generator: ResMut<ChunkMesher>,
    limits: Res<GeneratorLimits>,
    chunk_data: Query<&ChunkData>,
) {
    if generator.generating() >= limits.max_meshing_chunks {
        return;
    }
    if generator.to_generate.is_empty() {
        return;
    }
    let can_generate = limits.max_generating_chunks - generator.generating();
    let task_pool = bevy::tasks::AsyncComputeTaskPool::get();
    for _ in 0..generator.to_generate.len().min(can_generate) {
        let chunk_id = generator
            .to_generate
            .pop()
            .expect("to_generate should not be empty");
        #[cfg(feature = "log")]
        bevy::log::trace!("Generating mesh for chunk: {:?}", chunk_id);
        let Ok(chunk_data) = chunk_data.get(chunk_id) else {
            #[cfg(feature = "log")]
            bevy::log::error!("ChunkData not found for chunk: {:?}", chunk_id);
            continue;
        };
        generator.generating.insert(
            chunk_id,
            task_pool.spawn(chunk_data.clone().generate_mesh()),
        );
    }
}

pub(super) fn extract_finished_chunk_data(
    mut generator: ResMut<ChunkGenerator>,
    mut commands: bevy::prelude::Commands,
) {
    let ChunkGenerator {
        generating,
        old_generating,
        ..
    } = generator.as_mut();
    if generating.is_empty() {
        return;
    }
    std::mem::swap(generating, old_generating);
    for (entity, task) in old_generating.drain() {
        if !task.is_finished() {
            generating.insert(entity, task);
            continue;
        }
        #[cfg(feature = "log")]
        bevy::log::trace!("Extracting finished data for chunk: {:?}", entity);
        let data = bevy::tasks::block_on(task);
        commands.entity(entity).insert(data);
    }
}

pub(super) fn extract_finished_chunk_mesh(
    mut generator: ResMut<ChunkMesher>,
    mut commands: bevy::prelude::Commands,
    mut mesh_assets: ResMut<Assets<Mesh>>,
) {
    let ChunkMesher {
        generating,
        old_generating,
        ..
    } = generator.as_mut();
    if generating.is_empty() {
        return;
    }
    std::mem::swap(generating, old_generating);
    for (entity, task) in old_generating.drain() {
        if !task.is_finished() {
            generating.insert(entity, task);
            continue;
        }

        #[cfg(feature = "log")]
        bevy::log::trace!("Chunk {:?} has finished meshing inserting mesh", entity);

        let data = bevy::tasks::block_on(task);
        commands
            .entity(entity)
            .insert(Mesh3d(mesh_assets.add(data)));
    }
}
